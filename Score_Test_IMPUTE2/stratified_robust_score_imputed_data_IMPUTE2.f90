!########################################################################################
!########################################################################################
!
!  File        : stratified_robust_score_imputed_data_IMPUTE2.f90
!
!  Author      : Andrew Lee, The University of Cambridge
!                email: andrewl@srl.cam.ac.uk
!
!  Date        : 14/02/2012
!
!  Description : This program computes the the standard \chi^2, kinship adjusted and
!                robust test scores.
!
!  Usage       : 1 ) Compile the program
!                $ gfortran -O3 stratified_robust_score_imputed_data_IMPUTE2.f90 -o prog_strat_IMPUTE2.exe
!                2 ) Execute the program
!                $ ./prog_strat_IMPUTE2.exe
!
!########################################################################################
!       COPYWRITE ANDREW LEE, 2012, THE UNIVERSITY OF CAMBRIDGE
!       DO NOT EDIT, DISTRIBUTE OR COPY WITHOUT EXPRESS PERMISSION OF THE AUTHOR
!########################################################################################
!########################################################################################

      MODULE METHODS
      ! THIS MODULE CONTAINS SUBROUTINES AND FUNCTIONS USED IN MAIN PROGRAM.
      ! IT ALSO CONTAINS SOME COMMON DATA

      ! COMMON DATA
      IMPLICIT NONE
      ! THE VARIABLE 'REAL_KIND' CONTROLES THE PRECISION OF THE REAL VARIABLES
      ! USE REAL_KIND = 4 FOR SINGLE PRECISION
      ! USE REAL_KIND = 8 FOR DOUBLE PRECISION
      ! THIS MAY NOT BE THE CASE ON SOLARIS SYSTEMS ( I DON'T KNOW )
      INTEGER :: KIND_REAL
      PARAMETER( KIND_REAL = 8 )

      INTEGER, SAVE :: N_PEO, N_SNP, N_STRAT, N_FAM
      REAL( KIND = KIND_REAL ), ALLOCATABLE, DIMENSION( :, : ), SAVE :: GKIN, GENO
      REAL( KIND = KIND_REAL ), ALLOCATABLE, DIMENSION( : ), SAVE  :: PHENO
      INTEGER, ALLOCATABLE, DIMENSION( :, : ), SAVE :: FAM_START_POSN, N_PEO_FAM_STRAT
      INTEGER, ALLOCATABLE, DIMENSION( : ), SAVE :: STRAT_START_POSN, N_PEO_STRAT
      INTEGER, ALLOCATABLE, DIMENSION( : ), SAVE :: N_FAM_STRAT, ORDER
      CHARACTER( LEN = 32 ), ALLOCATABLE, DIMENSION( : ), SAVE :: DATAG_NAMES
      LOGICAL :: OVARIAN

      ! OVERLOAD THE SCALAR PRODUCT
      INTERFACE DOT
       MODULE PROCEDURE DOT_VV, DOT_VMV, DOT_V, DOT_VM
      END INTERFACE

      ! OVERLOAD THE REORDERING SUBROUTINES
      INTERFACE REORDER
       MODULE PROCEDURE REORDER_VECTOR_I, REORDER_VECTOR_R, REORDER_MATRIX_R
      END INTERFACE


      CONTAINS


!########################################################################################


      SUBROUTINE SUBTRACT_AVERAGE( VECTOR, LENGTH )
      ! THIS FUNCTION TAKES A VECTOR, OF LENGTH 'LENGTH', CALCULATES ITS MEAN,
      ! AND THEN SUBTRACTES THE MEAN FROM THE VECTOR, i.e.
      !          Y - \bar{Y}

      IMPLICIT NONE
      INTEGER :: LENGTH
      REAL( KIND = KIND_REAL ) :: VECTOR( LENGTH )
      INTEGER :: I
      REAL( KIND = KIND_REAL ) :: MEAN

      MEAN = 0_KIND_REAL

      DO I = 1, LENGTH
       MEAN = MEAN + VECTOR( I )
      ENDDO

      MEAN = MEAN/LENGTH

      DO I = 1, LENGTH
       VECTOR( I ) = VECTOR( I ) - MEAN
      ENDDO

      RETURN
      END SUBROUTINE SUBTRACT_AVERAGE


!########################################################################################


      SUBROUTINE SUBTRACT_AVERAGE_VAR( VECTOR, LENGTH, VAR )
      ! THIS FUNCTION TAKES A VECTOR, OF LENGTH 'LENGTH', CALCULATES ITS MEAN
      ! AND VARIANCE, AND THEN SUBTRACTES THE MEAN FROM THE VECTOR i.e.
      !          Y - \bar{Y}

      IMPLICIT NONE
      INTEGER :: LENGTH
      REAL( KIND = KIND_REAL ) :: VECTOR( LENGTH ), VAR
      INTEGER :: I
      REAL( KIND = KIND_REAL ) :: MEAN_SQ, MEAN

      MEAN = 0_KIND_REAL
      VAR = 0_KIND_REAL
      MEAN_SQ = 0_KIND_REAL

      DO I = 1, LENGTH
       MEAN = MEAN + VECTOR( I )
       MEAN_SQ = MEAN_SQ + VECTOR( I )**2
      ENDDO

      MEAN = MEAN/LENGTH
      VAR = ( MEAN_SQ - LENGTH*MEAN**2 )/( LENGTH - 1 )

      DO I = 1, LENGTH
       VECTOR( I ) = VECTOR( I ) - MEAN
      ENDDO

      RETURN
      END SUBROUTINE SUBTRACT_AVERAGE_VAR


!########################################################################################


      FUNCTION DOT_V( VECTOR_A, LENGTH )
      ! THIS FUNCTION CALCULATES THE SCALAR PRODUCT OF A VECTOR, OF LENGTH 'LENGTH',
      ! WITH ITSELF i.e.
      !          \sum_{ i = 1}^{LENGTH} Y_i^2

      IMPLICIT NONE
      INTEGER :: LENGTH
      REAL( KIND = KIND_REAL ) :: VECTOR_A( LENGTH ), DOT_V
      INTEGER :: I

      DOT_V = 0_KIND_REAL

      DO I = 1, LENGTH
       DOT_V = DOT_V + VECTOR_A( I )*VECTOR_A( I )
      ENDDO

      RETURN
      END FUNCTION DOT_V


!########################################################################################


      FUNCTION DOT_VV( VECTOR_A, VECTOR_B, LENGTH )
      ! THIS FUNCTION CALCULATES THE SCALAR PRODUCT OF TWO VECTORS, OF LENGTH 'LENGTH', i.e.
      !          \sum_{ i = 1}^{LENGTH} Y_i X_i

      IMPLICIT NONE
      INTEGER :: LENGTH
      REAL( KIND = KIND_REAL ) :: VECTOR_A( LENGTH ), VECTOR_B( LENGTH ), DOT_VV
      INTEGER :: I

      DOT_VV = 0_KIND_REAL

      DO I = 1, LENGTH
       DOT_VV = DOT_VV + VECTOR_A( I )*VECTOR_B( I )
      ENDDO

      RETURN
      END FUNCTION DOT_VV


!########################################################################################


      FUNCTION DOT_VMV( VECTOR_A, MATRIX_B, VECTOR_C, LENGTH )
      ! THIS FUNCTION CALCULATES THE SCALAR PRODUCT OF TWO VECTORS, OF LENGTH 'LENGTH',
      ! WITH A MATRIX IN BETWEEN,
      !         \sum_{ i = 1}^{LENGTH} \sum_{ j = 1}^{LENGTH} Y_i C_{i j} X_j

      IMPLICIT NONE
      INTEGER :: LENGTH
      REAL( KIND = KIND_REAL ) :: VECTOR_A( LENGTH ), VECTOR_C( LENGTH ), DOT_VMV
      REAL( KIND = KIND_REAL ) :: MATRIX_B( LENGTH, LENGTH ), TEMP, TEMP2
      INTEGER :: I, J

      DOT_VMV = 0_KIND_REAL

      DO I = 1, LENGTH
       TEMP = VECTOR_C( I )
       TEMP2 = 0_KIND_REAL
       DO J = 1, LENGTH
        TEMP2 = TEMP2 + VECTOR_A( J )*MATRIX_B( J, I )*TEMP
       ENDDO
       DOT_VMV = DOT_VMV + TEMP2
      ENDDO


      RETURN
      END FUNCTION DOT_VMV


!########################################################################################


      FUNCTION DOT_VM( VECTOR_A, MATRIX_B, LENGTH )
      ! THIS FUNCTION CALCULATES THE SCALAR PRODUCT OF A VECTOR, OF LENGTH 'LENGTH',
      ! WITH A MATRIX IN BETWEEN,
      !         \sum_{ i = 1}^{LENGTH} \sum_{ j = 1}^{LENGTH} Y_i C_{i j} Y_j

      IMPLICIT NONE
      INTEGER :: LENGTH
      REAL( KIND = KIND_REAL ) :: VECTOR_A( LENGTH ), DOT_VM
      REAL( KIND = KIND_REAL ) :: MATRIX_B( LENGTH, LENGTH ), TEMP, TEMP2
      INTEGER :: I, J

      DOT_VM = 0_KIND_REAL

      DO I = 1, LENGTH
       TEMP = VECTOR_A( I )
       TEMP2 = 0_KIND_REAL
       DO J = 1, LENGTH
        TEMP2 = TEMP2 + VECTOR_A( J )*MATRIX_B( J, I )*TEMP
       ENDDO
       DOT_VM = DOT_VM + TEMP2
      ENDDO

      RETURN
      END FUNCTION DOT_VM


!########################################################################################


      SUBROUTINE REORDER_VECTOR_I( VECTOR, LENGTH, ORDER )
      ! THIS SUBROUTINE TAKES A VECTOR OF INTEGERS, OF LENGTH 'LENGTH', AND REORDERS IT.

      IMPLICIT NONE
      INTEGER :: LENGTH
      INTEGER :: VECTOR( LENGTH ), TEMP_VECTOR( LENGTH ), ORDER( LENGTH )
      INTEGER :: I

      DO I = 1, LENGTH
       TEMP_VECTOR( I ) = VECTOR( ORDER( I ) )
      ENDDO

      VECTOR = TEMP_VECTOR
      RETURN
      END SUBROUTINE REORDER_VECTOR_I


!########################################################################################


      SUBROUTINE REORDER_VECTOR_R( VECTOR, LENGTH, ORDER )
      ! THIS SUBROUTINE TAKES A VECTOR OF REAL NUMBERS, OF LENGTH 'LENGTH', AND REORDERS IT.

      IMPLICIT NONE
      INTEGER :: LENGTH
      REAL( KIND = KIND_REAL ):: VECTOR( LENGTH ), TEMP_VECTOR( LENGTH )
      INTEGER :: ORDER( LENGTH )
      INTEGER :: I

      DO I = 1, LENGTH
       TEMP_VECTOR( ORDER( I ) ) = VECTOR( I )
      ENDDO

      VECTOR = TEMP_VECTOR
      RETURN
      END SUBROUTINE REORDER_VECTOR_R


!########################################################################################


      SUBROUTINE REORDER_MATRIX_R( MATRIX, LENGTH, ORDER )
      ! THIS SUBROUTINE TAKES A SQUARE MATRIX OF REAL NUMBERS, OF LENGTH 'LENGTH', AND REORDERS IT.

      IMPLICIT NONE
      INTEGER :: LENGTH
      REAL( KIND = KIND_REAL ):: MATRIX( LENGTH, LENGTH ), TEMP_MATRIX( LENGTH, LENGTH )
      INTEGER :: ORDER( LENGTH )
      INTEGER :: I, J

      DO I = 1, LENGTH
       DO J = 1, LENGTH
        TEMP_MATRIX( ORDER( I ), ORDER( J ) ) = MATRIX( I, J )
       ENDDO
      ENDDO

      MATRIX = TEMP_MATRIX
      RETURN
      END SUBROUTINE REORDER_MATRIX_R


!########################################################################################


      SUBROUTINE PHENO_KINSHIP_INPUT( FILE_1, FILE_2 )
      ! THIS SUBROUTINE READS IN THE PHENO AND KINSHIP DATA
      ! IT REORDERS THE KINSHIP MATRIX SO THAT THE INDIVIDULS ARE IN THE SAME ORDER AS IN THE PHENO DATA
      ! IT NOTES THE ORDER OF THE INDIVIDULS IN THE PHENO DATA, SO THAT THE GENO DATA CAN BE REORDERED

      IMPLICIT NONE
      INTEGER :: I, J, K, L, M
      INTEGER :: IO_STATUS, ALL_STATUS, N_PEO_GKIN
      INTEGER, ALLOCATABLE, DIMENSION( : ) :: ORDER_2, ORDER_3
      INTEGER, ALLOCATABLE, DIMENSION( :, : ) :: STRATA, FAM_STRAT
      REAL( KIND = KIND_REAL ) :: TEMP_R
      REAL( KIND = KIND_REAL ), ALLOCATABLE, DIMENSION( : )  :: TEMP_RA
      REAL( KIND = KIND_REAL ), ALLOCATABLE, DIMENSION( :, : )  :: TEMP_GKIN
      CHARACTER( LEN = 32 ) :: WORD( 5 )
      CHARACTER( LEN = 256 ) :: FILE_1, FILE_2
      CHARACTER( LEN = 32 ), ALLOCATABLE, DIMENSION( : ) :: GKIN_NAMES, FOUND_FAMILY
      LOGICAL :: IS_NEW_FAM, IS_NEW_STR

      CHARACTER( LEN = 32 ), ALLOCATABLE, DIMENSION( : ) :: FOUND_STRAT
      INTEGER :: PHENO_COLUMN
      REAL( KIND = KIND_REAL ) :: BCOC_PHENO( 2 )
      LOGICAL :: FOUND
      LOGICAL :: STOP_ERROR
      IF( OVARIAN )THEN
       PHENO_COLUMN = 2
      ELSE
       PHENO_COLUMN = 1
      ENDIF

      OPEN( UNIT = 22, &
            FILE = TRIM( ADJUSTL( FILE_1 ) ), &
            STATUS = 'OLD', &
            ACTION = 'READ', &
            IOSTAT = IO_STATUS )
      IF( IO_STATUS .NE. 0 )  CALL FATAL_FILE_OPENING_ERROR( TRIM( ADJUSTL( FILE_1 ) ), 'PHENO_KINSHIP_INPUT', IO_STATUS )

      READ( 22, *, IOSTAT = IO_STATUS ) WORD
      IF( IO_STATUS .NE. 0 ) CALL FATAL_FILE_READING_ERROR( TRIM( FILE_1 ), 'PHENO_KINSHIP_INPUT', -1, IO_STATUS )


      ! THE FIRST SWEEP THROUGH THE FILE COUNTS THE NUMBER OF PEOPLE ( N_PEO )
      N_PEO = 0
      IO_STATUS = 0
      DO
       READ( 22, *, IOSTAT = IO_STATUS ) WORD( 1 )
       IF( IO_STATUS .NE. 0 ) EXIT
       N_PEO = N_PEO + 1
      ENDDO
      IF( N_PEO .EQ. 0 ) CALL FATAL_FILE_READING_ERROR( TRIM( FILE_1 ), 'PHENO_KINSHIP_INPUT', -2, IO_STATUS )


      WRITE( *, * )'   NUMBER OF PEOPLE: ', N_PEO

      ! ALLOCATE SOME ARRAYS TO THE CORRECT SIZE
      ALLOCATE( DATAG_NAMES( N_PEO ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'DATAG_NAMES', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      ALLOCATE( GKIN_NAMES( N_PEO ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'GKIN_NAMES', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      ALLOCATE( STRATA( N_PEO, 2 ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'STRATA', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      ALLOCATE( PHENO( N_PEO ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'PHENO', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      ALLOCATE( GKIN( N_PEO, N_PEO ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'GKIN', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      ALLOCATE( ORDER( N_PEO ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'ORDER', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      ALLOCATE( ORDER_2( N_PEO ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'ORDER_2', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      ALLOCATE( FOUND_STRAT( N_PEO ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'FOUND_STRAT', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      ALLOCATE( FOUND_FAMILY( N_PEO ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'FOUND_FAMILY', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      ! REWIND THE FILE FOR THE SECOND SWEEP
      REWIND( 22 )
      WRITE( *, * )'   READING IN THE INDIVIDUALS PHENOTYPES.'

      READ( 22, *, IOSTAT = IO_STATUS ) WORD
      IF( IO_STATUS .NE. 0 ) CALL FATAL_FILE_READING_ERROR( TRIM( FILE_1 ), 'PHENO_KINSHIP_INPUT', -3, IO_STATUS )

      ! THE SECOND SWEEP THROUGH THE FILE READS IN THE NAMES, PHENOTYPES,
      ! STRATA AND FAMILY FOR EACH INDIVIDUAL.
      ! WE COUNT THE NUMBER OF STRATA, AND THE NUMBER OF FAMILIES
      ! WE ASSIGN EACH STRAT AND EACH FAMILY A UNIQUE INTEGER,
      ! BASED ON THE ORDER THEY ARE ENCOUNTERED IN THE FILE
      N_STRAT = 0
      N_FAM = 0
      DO I = 1, N_PEO

       READ( 22, *, IOSTAT = IO_STATUS ) DATAG_NAMES( I ), WORD( 1 ), WORD( 2 ), &
                                         BCOC_PHENO( 1 ), BCOC_PHENO( 2 )
       IF( IO_STATUS .NE. 0 ) CALL FATAL_FILE_READING_ERROR( TRIM( FILE_1 ), 'PHENO_KINSHIP_INPUT', I, IO_STATUS )

       PHENO( I ) = BCOC_PHENO( PHENO_COLUMN )

       IS_NEW_STR = .TRUE.
       DO K = 1, N_STRAT
        IF( TRIM( ADJUSTL( WORD( 1 ) ) ) .EQ. TRIM( ADJUSTL( FOUND_STRAT( K ) ) ) )THEN
         STRATA( I, 1 ) = K
         IS_NEW_STR = .FALSE.
        ENDIF
       ENDDO
       IF( IS_NEW_STR ) THEN
        N_STRAT = N_STRAT + 1
        STRATA( I, 1 ) = N_STRAT
        FOUND_STRAT( N_STRAT ) = TRIM( ADJUSTL( WORD( 1 ) ) )
       ENDIF

       IS_NEW_FAM = .TRUE.
       DO K = 1, N_FAM
        IF( TRIM( ADJUSTL( WORD( 2 ) ) ) .EQ. TRIM( ADJUSTL( FOUND_FAMILY( K ) ) ) )THEN
         STRATA( I, 2 ) = K
         IS_NEW_FAM = .FALSE.
        ENDIF
       ENDDO
       IF( IS_NEW_FAM ) THEN
        N_FAM = N_FAM + 1
        STRATA( I, 2 ) = N_FAM
        FOUND_FAMILY( N_FAM ) = TRIM( ADJUSTL( WORD( 2 ) ) )
       ENDIF

      ENDDO

      CLOSE( 22 )

      WRITE( *, * )'   NUMBER OF STRATA:', N_STRAT

      ! WE ARE FINISHED WITH THESE ARRAYS, SO DEALLOCATE THEM
      DEALLOCATE( FOUND_STRAT, FOUND_FAMILY )

      ! ALLOCATE THESE ARRAYS
      ALLOCATE( N_PEO_STRAT( N_STRAT ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'N_PEO_STRAT', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      ALLOCATE( N_FAM_STRAT( N_STRAT ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'N_FAM_STRAT', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      ALLOCATE( FAM_STRAT( N_STRAT, N_FAM ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'FAM_STRAT', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      ALLOCATE( N_PEO_FAM_STRAT( N_STRAT, N_FAM ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'N_PEO_FAM_STRAT', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      N_PEO_STRAT = 0
      N_FAM_STRAT = 0


      ! SORT THE INDIVIDUALS. FIRSTLY BY STRAT, AND THEN BY FAMILY, WITHIN EACH STRATA
      L = 0
      ORDER = 0
      DO I = 1, N_STRAT
       DO J = 1, N_FAM
        DO K = 1, N_PEO
         IF( ( STRATA( K, 1 ) .EQ. I ) .AND. ( STRATA( K, 2 ) .EQ. J ) ) THEN
          L = L + 1
          ORDER( K ) = L
          N_PEO_STRAT( I ) = N_PEO_STRAT( I ) + 1

          IS_NEW_FAM = .TRUE.
          DO M = 1, N_FAM_STRAT( I )
           IF( J .EQ. FAM_STRAT( I, M ) ) THEN
            IS_NEW_FAM = .FALSE.
            N_PEO_FAM_STRAT( I, M ) =  N_PEO_FAM_STRAT( I, M ) + 1
           ENDIF
          ENDDO
          IF( IS_NEW_FAM ) THEN
           N_FAM_STRAT( I ) = N_FAM_STRAT( I ) + 1
           FAM_STRAT( I, N_FAM_STRAT( I ) ) = J
           N_PEO_FAM_STRAT( I, N_FAM_STRAT( I ) ) = 1
          ENDIF

         ENDIF
        ENDDO
       ENDDO
      ENDDO

     ! CHECK THAT EACH INDIVIDUAL HAS BEEN SORTED ONCE AND ONLY ONCE
      DO I = 1, N_PEO
       IF( ORDER( I ) .EQ. 0 ) THEN
        WRITE( *, * )'PERSON ', I, ' HAS NOT BEEN ORDERED.'
        WRITE( *, * )'STOPPING PREMATURELY.'
        CALL CLEAN_METHODS( )
        CALL EXIT( 3 )
       ENDIF
      ENDDO
      IF( L .GT. N_PEO ) THEN
       WRITE( *, * )'AT LEAST ONE PERSON HAS BEEN ALLOCATED TWICE.'
       WRITE( *, * )'STOPPING PREMATURELY.'
       CALL CLEAN_METHODS( )
       CALL EXIT( 4 )
      ENDIF

      ! WE ARE FINISHED WITH THIS ARRAYS, SO DEALLOCATE THEM
      DEALLOCATE( FAM_STRAT, STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'FAM_STRAT', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      DEALLOCATE( STRATA, STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'STRATA', 'PHENO_KINSHIP_INPUT', ALL_STATUS )


      ! ALLOCATE THESE ARRAYS
      ALLOCATE( STRAT_START_POSN( N_STRAT ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'STRAT_START_POSN', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      ALLOCATE( FAM_START_POSN( N_STRAT, MAXVAL( N_FAM_STRAT ) ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'STRAT_START_POSN', 'PHENO_KINSHIP_INPUT', ALL_STATUS )


      ! REORDER THE PHENO ARRAY
      CALL REORDER( PHENO, N_PEO, ORDER )

      ! CALCULATE THE START POSITION FOR EACH STATA IN THE NEW ORDERED ARRAY
      STRAT_START_POSN( 1 ) = 1
      DO I = 2, N_STRAT
       STRAT_START_POSN( I ) = STRAT_START_POSN( I - 1 ) + N_PEO_STRAT( I - 1 )
      ENDDO

      ! CALCULATE THE START POSITION FOR EACH FAMILY, WITHIN EACH STRATA IN THE NEW ORDERED ARRAY
      DO I = 1, N_STRAT
       FAM_START_POSN( I, 1 ) = STRAT_START_POSN( I )
       DO J = 2, N_FAM_STRAT( I )
        FAM_START_POSN( I, J ) = FAM_START_POSN( I, J - 1 ) + N_PEO_FAM_STRAT( I, J - 1 )
       ENDDO
      ENDDO

      ! READ IN THE KINSHIP MATRIX
      WRITE( *, * )'   READING IN THE KINSHIP MATRIX.'

      OPEN( UNIT = 77, &
            FILE = TRIM( ADJUSTL( FILE_2 ) ), &
            STATUS = 'OLD', &
            ACTION = 'READ', &
            IOSTAT = IO_STATUS )
      IF( IO_STATUS .NE. 0 )  CALL FATAL_FILE_OPENING_ERROR( TRIM( ADJUSTL( FILE_2 ) ), 'PHENO_KINSHIP_INPUT', IO_STATUS )

      ! FIRST COUNT THE NUMBER OF PEOPLE IN THE KINSHIP MATRIX
      N_PEO_GKIN = 0
      DO
       READ( 77, *, IOSTAT = IO_STATUS ) WORD( 1 )
       IF( IO_STATUS .NE. 0 ) EXIT
       N_PEO_GKIN = N_PEO_GKIN + 1
      ENDDO

      IF( N_PEO_GKIN .EQ. 0 ) CALL FATAL_FILE_READING_ERROR( TRIM( FILE_2 ), 'PHENO_KINSHIP_INPUT', I, IO_STATUS )

      IF( N_PEO_GKIN .LT. N_PEO ) THEN
       ! THERE ARE NOT ENOUGH PEOPLE IN THE KINSHIP MATRIX, SO STOP

       WRITE( *, * )'INSUFFICIENT PEOPLE IN KINSHIP FILE, "', TRIM( ADJUSTL( FILE_2 ) ), '".'
       WRITE( *, * ) N_PEO_GKIN
       WRITE( *, * )'STOPPING PREMATURELY.'
       CLOSE( 77 )
       CALL CLEAN_METHODS( )
       CALL EXIT( 5 )

      ELSEIF( N_PEO_GKIN .EQ. N_PEO ) THEN
       ! THERE ARE THE SAME NUMBER OF PEOPLE IN THE KINSHIP MATRIX AS THE PHENO FILE

       REWIND( 77 )	
       DO I = 1, N_PEO
        READ( 77, *, IOSTAT = IO_STATUS ) GKIN_NAMES( I ), GKIN( I, : )
        IF( IO_STATUS .NE. 0 ) CALL FATAL_FILE_READING_ERROR( TRIM( FILE_2 ), 'PHENO_KINSHIP_INPUT', I, IO_STATUS )
       ENDDO

       CLOSE( 77 )

       ! CHECK THAT EVERYONE IN THE PHENO FILE IS ALSO IN THE KINSHIP MATRIX
       STOP_ERROR = .FALSE.
       DO I = 1, N_PEO
        FOUND = .FALSE.
        DO J = 1, N_PEO
         IF( TRIM( ADJUSTL( DATAG_NAMES( I ) ) ) .EQ. TRIM( ADJUSTL( GKIN_NAMES( J ) ) ) ) THEN
          FOUND = .TRUE. 
          EXIT
         ENDIF
        ENDDO
        IF( .NOT. FOUND ) THEN
         WRITE( *, * )'PERSON "', TRIM( ADJUSTL( DATAG_NAMES( I ) ) ), '" IS IN PHENO FILE BUT NOT IN THE KINSHIP FILE.'
         STOP_ERROR = .TRUE.
        ENDIF
       ENDDO
       IF( STOP_ERROR ) THEN
        WRITE( *, * )'STOPPING PREMATURELY.'
        CALL CLEAN_METHODS( )
        CALL EXIT( 16 )
       ENDIF

      ELSE
       ! THERE ARE MORE PEOPLE IN THE KINSHIP MATRIX THAN THE PHENO MATRIX,
       ! THUS WE NEED TO CUT OUT THE IRRELEVANT PEOPLE

       ALLOCATE( TEMP_RA( N_PEO_GKIN ), STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'TEMP_RA', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

       ALLOCATE( TEMP_GKIN( N_PEO, N_PEO_GKIN ), STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'TEMP_GKIN', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

       ALLOCATE( ORDER_3( N_PEO ), STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'ORDER_3', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

       REWIND( 77 )
       K = 0	
       DO I = 1, N_PEO_GKIN
        READ( 77, *, IOSTAT = IO_STATUS ) WORD( 1 ), TEMP_RA
        IF( IO_STATUS .NE. 0 ) CALL FATAL_FILE_READING_ERROR( TRIM( FILE_2 ), 'PHENO_KINSHIP_INPUT', I, IO_STATUS )
        DO J = 1, N_PEO
         IF( TRIM( ADJUSTL( DATAG_NAMES( J ) ) ) .EQ. TRIM( ADJUSTL( WORD( 1 ) ) ) ) THEN
          K = K + 1
          GKIN_NAMES( K ) = TRIM( ADJUSTL( WORD( 1 ) ) )
          TEMP_GKIN( K, : ) = TEMP_RA
          ORDER_3( K ) = I
          EXIT
         ENDIF
        ENDDO
       ENDDO

       CLOSE( 77 )

       ! CHECK THAT EVERYONE IN THE PHENO FILE IS ALSO IN THE KINSHIP MATRIX
       STOP_ERROR = .FALSE.
       DO I = 1, N_PEO
        FOUND = .FALSE.
        DO J = 1, N_PEO
         IF( TRIM( ADJUSTL( DATAG_NAMES( I ) ) ) .EQ. TRIM( ADJUSTL( GKIN_NAMES( J ) ) ) ) THEN
          FOUND = .TRUE. 
          EXIT
         ENDIF
        ENDDO
        IF( .NOT. FOUND ) THEN
         WRITE( *, * )'PERSON "', TRIM( ADJUSTL( DATAG_NAMES( I ) ) ), '" IS IN PHENO FILE BUT NOT IN THE KINSHIP FILE.'
         STOP_ERROR = .TRUE.
        ENDIF
       ENDDO
       IF( STOP_ERROR ) THEN
        WRITE( *, * )'STOPPING PREMATURELY.'
        CALL CLEAN_METHODS( )
        CALL EXIT( 17 )
       ENDIF


       DO I = 1, N_PEO
        GKIN( :, I ) = TEMP_GKIN( :, ORDER_3( I ) )
       ENDDO

       DEALLOCATE( TEMP_RA, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'TEMP_RA', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

       DEALLOCATE( TEMP_GKIN, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'TEMP_GKIN', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

       DEALLOCATE( ORDER_3, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'ORDER_3', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      ENDIF

      ! DETERMIN THE CORRECT ORDER OF THE KINSHIP ARRAY
      ORDER_2 = 0
      DO I = 1, N_PEO
       DO J = 1, N_PEO
        IF( TRIM( ADJUSTL( DATAG_NAMES( I ) ) ) .EQ. TRIM( ADJUSTL( GKIN_NAMES( J ) ) ) ) THEN
         ORDER_2( J ) = ORDER( I )
        ENDIF
       ENDDO
      ENDDO

     ! CHECK THAT EACH INDIVIDUAL IN THE PHENO FILE IS ALSO IN GKIN ONCE
     DO I = 1, N_PEO
      IF( ORDER_2( I ) .EQ. 0 ) THEN
       WRITE( *, * )'PERSON ', I, ' IS NOT IN THE KINSHIP MATRIX.'
       WRITE( *, * )'STOPPING PREMATURELY.'
       CALL CLEAN_METHODS( )
       CALL EXIT( 6 )
      ENDIF
     ENDDO
     DO I = 1, N_PEO - 1
      DO J = I + 1, N_PEO
       IF( ORDER_2( J ) .EQ. ORDER_2( I ) ) THEN
        WRITE( *, * )'PERSON ', I, ' IS IN THE KINSHIP MATRIX TWICE.'
        WRITE( *, * )'STOPPING PREMATURELY.'
       ENDIF
      ENDDO
     ENDDO

      ! REORDER THE KINSIP ARRAY
      CALL REORDER( GKIN, N_PEO, ORDER_2 )


      ! WE ARE FINISHED WITH THESE ARRAYS, SO DEALLOCATE THEM
      DEALLOCATE( ORDER_2, STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'ORDER_2', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      DEALLOCATE( GKIN_NAMES, STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'GKIN_NAMES', 'PHENO_KINSHIP_INPUT', ALL_STATUS )

      RETURN
      END SUBROUTINE PHENO_KINSHIP_INPUT


!########################################################################################


      SUBROUTINE FATAL_FILE_OPENING_ERROR( FILE_NAME, FN_NAME, ERROR_N )
      ! THIS SUBROUTINE IS CALLED WHEN THERE IS A FILE OPENING ERROR
      ! IT WRITES AN ERROR MESSAGE TO THE SCREEN, AND THEN STOPS THE CODE
      IMPLICIT NONE
      INTEGER :: ERROR_N
      CHARACTER( LEN = * ) :: FILE_NAME, FN_NAME

      WRITE( *, * )'FATAL ERROR WHILE TRYING TO OPEN THE FILE "'//TRIM( ADJUSTL( FILE_NAME ) )// &
                 '" IN SUBROUTINE/FUNCTION '//TRIM( ADJUSTL( FN_NAME ) )//'".'
      WRITE( *, * )"ERROR NUMBER ", ERROR_N
      WRITE( *, * )"STOPPING PREMATURELY."
      CALL CLEAN_METHODS( )
      CALL EXIT( 8 )
      END SUBROUTINE FATAL_FILE_OPENING_ERROR


!########################################################################################


      SUBROUTINE FATAL_FILE_READING_ERROR( FILE_NAME, FN_NAME, POSN, ERROR_N )
      ! THIS SUBROUTINE IS CALLED WHEN THERE IS A FILE READING ERROR
      ! IT WRITES AN ERROR MESSAGE TO THE SCREEN, AND THEN STOPS THE CODE
      IMPLICIT NONE
      INTEGER :: ERROR_N, POSN
      CHARACTER( LEN = * ) :: FILE_NAME, FN_NAME


      WRITE( *, * )'FATAL ERROR WHILE TRYING TO READ FILE "'//TRIM( ADJUSTL( FILE_NAME ) )// &
                 '" IN SUBROUTINE/FUNCTION "'//TRIM( ADJUSTL( FN_NAME ) )// &
                 '", AT POSITION ', POSN
      WRITE( *, * )"ERROR NUMBER ", ERROR_N
      WRITE( *, * )"STOPPING PREMATURELY."
      CALL CLEAN_METHODS( )
      CALL EXIT( 9 )
      END SUBROUTINE FATAL_FILE_READING_ERROR


!########################################################################################


      SUBROUTINE FILE_OPENING_ERROR( FILE_NAME, FN_NAME, ERROR_N )
      ! THIS SUBROUTINE IS CALLED WHEN THERE IS A FILE OPENING ERROR
      ! IT WRITES AN ERROR MESSAGE TO THE SCREEN.
      IMPLICIT NONE
      INTEGER :: ERROR_N
      CHARACTER( LEN = * ) :: FILE_NAME, FN_NAME

      WRITE( *, * )'ERROR WHILE TRYING TO OPEN THE FILE "'//TRIM( ADJUSTL( FILE_NAME ) )// &
                 '" IN SUBROUTINE/FUNCTION '//TRIM( ADJUSTL( FN_NAME ) )//'".'
      WRITE( *, * )"ERROR NUMBER ", ERROR_N

      RETURN
      END SUBROUTINE FILE_OPENING_ERROR


!########################################################################################


      SUBROUTINE FILE_READING_ERROR( FILE_NAME, FN_NAME, POSN, ERROR_N )
      ! THIS SUBROUTINE IS CALLED WHEN THERE IS A FILE READING ERROR
      ! IT WRITES AN ERROR MESSAGE TO THE SCREEN.
      IMPLICIT NONE
      INTEGER :: ERROR_N, POSN
      CHARACTER( LEN = * ) :: FILE_NAME, FN_NAME

      WRITE( *, * )'ERROR WHILE TRYING TO READ FILE "'//TRIM( ADJUSTL( FILE_NAME ) )// &
                 '" IN SUBROUTINE/FUNCTION "'//TRIM( ADJUSTL( FN_NAME ) )// &
                 '", AT POSITION ', POSN
      WRITE( *, * )"ERROR NUMBER ", ERROR_N

      RETURN
      END SUBROUTINE FILE_READING_ERROR


!########################################################################################


      SUBROUTINE ALLOCATION_ERROR( ARRAY_NAME, FN_NAME, STAT )
      ! THIS SUBROUTINE IS CALLED WHEN THERE IS AN ERROR ALLOCATING AN ARRAY
      ! IT WRITES AN ERROR MESSAGE TO THE SCREEN, AND THEN STOPS THE CODE
      IMPLICIT NONE
      INTEGER :: STAT
      CHARACTER( LEN = * ) :: ARRAY_NAME, FN_NAME

      WRITE( *, * )'FAILURE TO ALLOCATE "'//TRIM( ADJUSTL( ARRAY_NAME ) )// &
                 '" IN SUBROUTINE/FUNCTION "'//TRIM( ADJUSTL( FN_NAME ) )//'".'
      WRITE( *, * )"ERROR STATUS ", STAT
      WRITE( *, * )"STOPPING PREMATURELY."
      CALL CLEAN_METHODS( )
      CALL EXIT( 1 )
      END SUBROUTINE ALLOCATION_ERROR


!########################################################################################


      SUBROUTINE DEALLOCATION_ERROR( ARRAY_NAME, FN_NAME, STAT )
      ! THIS SUBROUTINE IS CALLED WHEN THERE IS AN ERROR DEALLOCATING AN ARRAY
      ! IT WRITES AN ERROR MESSAGE TO THE SCREEN, AND THEN STOPS THE CODE
      IMPLICIT NONE
      INTEGER :: STAT
      CHARACTER( LEN = * ) :: ARRAY_NAME, FN_NAME

      WRITE( *, * )'FAILURE TO DEALLOCATE "'//TRIM( ADJUSTL( ARRAY_NAME ) )// &
                 '" IN SUBROUTINE/FUNCTION "'//TRIM( ADJUSTL( FN_NAME ) )//'".'
      WRITE( *, * )"ERROR STATUS ", STAT
      WRITE( *, * )"STOPPING PREMATURELY."
      CALL CLEAN_METHODS( )
      CALL EXIT( 2 )
      END SUBROUTINE DEALLOCATION_ERROR


!########################################################################################


      SUBROUTINE CLEAN_METHODS( )
      ! THIS SUBROUTINE DEALLOCATES ARRAYS
      IMPLICIT NONE
      INTEGER :: ALL_STATUS

      IF( ALLOCATED( GKIN ) ) THEN
       DEALLOCATE( GKIN, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'GKIN', 'CLEAN_METHODS', ALL_STATUS )
      ENDIF

      IF( ALLOCATED( GENO ) ) THEN
       DEALLOCATE( GENO, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'GENO', 'CLEAN_METHODS', ALL_STATUS )
      ENDIF

      IF( ALLOCATED( PHENO ) ) THEN
       DEALLOCATE( PHENO, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'PHENO', 'CLEAN_METHODS', ALL_STATUS )
      ENDIF

      IF( ALLOCATED( FAM_START_POSN ) ) THEN
       DEALLOCATE( FAM_START_POSN, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'FAM_START_POSN', 'CLEAN_METHODS', ALL_STATUS )
      ENDIF

      IF( ALLOCATED( N_PEO_FAM_STRAT ) ) THEN
       DEALLOCATE( N_PEO_FAM_STRAT, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'N_PEO_FAM_STRAT', 'CLEAN_METHODS', ALL_STATUS )
      ENDIF

      IF( ALLOCATED( STRAT_START_POSN ) ) THEN
       DEALLOCATE( STRAT_START_POSN, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'STRAT_START_POSN', 'CLEAN_METHODS', ALL_STATUS )
      ENDIF

      IF( ALLOCATED( N_PEO_STRAT ) ) THEN
       DEALLOCATE( N_PEO_STRAT, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'N_PEO_STRAT', 'CLEAN_METHODS', ALL_STATUS )
      ENDIF

      IF( ALLOCATED( N_FAM_STRAT ) ) THEN
       DEALLOCATE( N_FAM_STRAT, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'N_FAM_STRAT', 'CLEAN_METHODS', ALL_STATUS )
      ENDIF

      IF( ALLOCATED( ORDER ) ) THEN
       DEALLOCATE( ORDER, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'ORDER', 'CLEAN_METHODS', ALL_STATUS )
      ENDIF

      IF( ALLOCATED( DATAG_NAMES ) ) THEN
       DEALLOCATE( DATAG_NAMES, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'DATAG_NAMES', 'CLEAN_METHODS', ALL_STATUS )
      ENDIF

      RETURN
      END SUBROUTINE CLEAN_METHODS


!########################################################################################


      END MODULE METHODS


!########################################################################################
!########################################################################################


      PROGRAM  STRATIFIED_ROBUST
      ! THIS IS THE MAIN PROGRAM. IT READS IN THE PHENOTYPIC DATA, THE KINSHIP MATRIX,
      ! AND THE GENOTYPIC DATA, AND CALCULATES THREE TEST STATISTICS.
      ! NUM = \sum_i ( Y_i - \bar{Y_i} ).( G_i - \bar{G_i} )
      ! WHERE i LABELS THE STRATUM, Y IS THE PHENOTYPE, AND G IS THE GENOTYPE
      ! DENOM( 1 ) = \sum_i VAR( G_i ) ( Y_i - \bar{Y_i} ).( Y_i - \bar{Y_i} )
      ! DENOM( 2 ) = \sum_i VAR( G_i ) ( Y_i - \bar{Y_i} )C^{i}( Y_i - \bar{Y_i} )
      ! DENOM( 3 ) = \sum_i \sum_k [( G_{i, k} - \bar{G_i} )( Y_{i, k} - \bar{Y_i} )]^2
      ! WHERE k, LABELS THE FAMILY WITH THE STRATUM i, AND C^{i} IS THE KINSHIP MATRIX
      ! FOR THE STRATUM i
      !
      ! THE STANDARD \chi^2 TEST STATISTIC IS
      ! NUM^2/DENOM( 1 )
      !
      ! THE KINSHIP ADJUSTED TEST STATISTIC IS
      ! NUM^2/DENOM( 2 )
      !
      ! THE ROBUST TEST STATISTIC IS
      ! NUM^2/DENOM( 3 )

      USE METHODS
      IMPLICIT NONE
      INTEGER :: MAX_ALLELE_LENGTH
      PARAMETER( MAX_ALLELE_LENGTH = 1000000 )
      INTEGER :: I, J, K
      INTEGER :: ALL_STATUS, IO_STATUS, ERROR_STAT, ERROR_POS
      REAL( KIND = KIND_REAL ) :: VAR_G, DENOM( 3 ), NUMR, TEMP
      REAL( KIND = KIND_REAL ), ALLOCATABLE, DIMENSION( : ) :: G, TEMP_RA
      REAL( KIND = KIND_REAL ), ALLOCATABLE, DIMENSION( :, : ) :: C, NUM
      CHARACTER( LEN = 32 ) :: WORDS( 7 ), INFO( 3 )
      CHARACTER( LEN = MAX_ALLELE_LENGTH + 1 ) :: ALLELES( 2 )
      CHARACTER( LEN = 256 ) :: PHENO_FILE, GENO_FILE, INPUT_FILE
      CHARACTER( LEN = 256 ) :: KINSHIP_FILE, RESULTS_FILE
      LOGICAL :: FILE_EXIST

 100  FORMAT( 22( A, :',' ) )
 101  FORMAT( 'WARNING: FOR SNP "', A, '", ALLELE ', I1, ' IS TOO LONG' )

      NAMELIST / filenames / PHENO_FILE, KINSHIP_FILE, &
                             GENO_FILE, RESULTS_FILE, OVARIAN

      INPUT_FILE = "file_names_IMPUTE2.nml"

      OPEN( UNIT = 34, FILE = TRIM( ADJUSTL( INPUT_FILE ) ), STATUS = 'OLD' )
      READ( UNIT = 34, NML = filenames )
      CLOSE( 34 )


      WRITE( *, * )
      WRITE( *, * ) 'SETTINGS:'
      WRITE( *, * )
      WRITE( *, * ) 'PHENO_FILE: "'//TRIM( ADJUSTL( PHENO_FILE ) )//'"'
      WRITE( *, * ) 'KINSHIP_FILE: "'//TRIM( ADJUSTL( KINSHIP_FILE ) )//'"'
      WRITE( *, * ) 'GENO_FILE: "'//TRIM( ADJUSTL( GENO_FILE ) )//'"'
      WRITE( *, * ) 'RESULTS_FILE: "'//TRIM( ADJUSTL( RESULTS_FILE ) )//'"'
      WRITE( *, * ) 'OVARIAN: ', OVARIAN
      WRITE( *, * )
      WRITE( *, * )

      ! CHECK THAT ALL THE REQUIRED FILES EXIST
      INQUIRE( FILE = TRIM( ADJUSTL( PHENO_FILE ) ), EXIST = FILE_EXIST )
      IF( .NOT. FILE_EXIST ) THEN
       WRITE( *, * ) 'ERROR: THE FILE "'//TRIM( ADJUSTL( PHENO_FILE ) )//'" DOES NOT EXIST'
       WRITE( *, * ) 'STOPPING PREMATURELY.'
       CALL CLEAN_METHODS( )
       CALL EXIT( 11 )
      ENDIF

      INQUIRE( FILE = TRIM( ADJUSTL( KINSHIP_FILE ) ), EXIST = FILE_EXIST )
      IF( .NOT. FILE_EXIST ) THEN
       WRITE( *, * ) 'ERROR: THE FILE "'//TRIM( ADJUSTL( KINSHIP_FILE ) )//'" DOES NOT EXIST'
       WRITE( *, * ) 'STOPPING PREMATURELY.'
       CALL CLEAN_METHODS( )
       CALL EXIT( 12 )
      ENDIF

      INQUIRE( FILE = TRIM( ADJUSTL( GENO_FILE ) ), EXIST = FILE_EXIST )
      IF( .NOT. FILE_EXIST ) THEN
       WRITE( *, * ) 'ERROR: THE FILE "'//TRIM( ADJUSTL( GENO_FILE ) )//'" DOES NOT EXIST'
       WRITE( *, * ) 'STOPPING PREMATURELY.'
       CALL CLEAN_METHODS( )
       CALL EXIT( 14 )
      ENDIF


      ! READ IN THE PHENOTYPICAL DATA, AND SORT IT VIA STRATUM, AND THEN FAMILY
      ! ALSO READ IN THE KINSHIP MATRIX, AND REOREDER IT TO THE SAME ORDER AS THE PHENO DATA
      WRITE( *, * ) 'READING IN THE PHENO DATA, AND THE KINSHIP MATRIX.'

      CALL PHENO_KINSHIP_INPUT( PHENO_FILE, KINSHIP_FILE )


      ! ALLOCATE THE MATRICES
      ALLOCATE( G( N_PEO ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'G', 'MAIN PROGRAM', ALL_STATUS )

      ALLOCATE( NUM( N_STRAT, 3 ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'NUM', 'MAIN PROGRAM', ALL_STATUS )

      ALLOCATE( TEMP_RA( 3*N_PEO ), STAT = ALL_STATUS )
      IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'TEMP_RA', 'MAIN PROGRAM', ALL_STATUS )


      ! WE DO THE CALCULATIONS INVOLVING THE PHENOTYPIC DATA ONLY, AS THIS WILL BE THE
      ! SAME FOR EACH SNP, ON EACH CHROMOSOME, SO THERE IS NO POINT IS REPEATING IT

      WRITE( *, * )'PERFORMING INITIAL CALCULATIONS.'

      ! LOOP OVER THE STRATA
      DO I = 1, N_STRAT

       ! TAKE THE SECTION OF THE PHENOTYPIC VECTOR CORRESPONDING TO THIS STRATUM,
       ! CALCULATE THE AVERAGE, AND SUBREACT THE AVERAGE FOR THE VECTOR.
       ! i.e. CREATE ( Y_i - \bar{Y_i} ), WHERE i LABELS THE STRATUM
       CALL SUBTRACT_AVERAGE( PHENO( STRAT_START_POSN( I ): STRAT_START_POSN( I ) + &
                              N_PEO_STRAT( I ) - 1 ), N_PEO_STRAT( I ) )

       ! TAKT THE DOT PRODUCT ( Y_i - \bar{Y_i} ).( Y_i - \bar{Y_i} )
       NUM( I, 1 ) = DOT( PHENO( STRAT_START_POSN( I ):STRAT_START_POSN( I ) + &
                          N_PEO_STRAT( I ) - 1 ), N_PEO_STRAT( I ) )

       ! EXTRACT THE PIECE OF THE KINSHIP MATRIX CORERESPONDING TO THIS STRATUM, C^{i}
       ALLOCATE( C( N_PEO_STRAT( I ), N_PEO_STRAT( I ) ), STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL ALLOCATION_ERROR( 'C', 'MAIN PROGRAM', ALL_STATUS )

       C = GKIN( STRAT_START_POSN( I ):STRAT_START_POSN( I ) + N_PEO_STRAT( I ) - 1, &
                 STRAT_START_POSN( I ):STRAT_START_POSN( I ) + N_PEO_STRAT( I ) - 1 )

       ! TAKT THE DOT PRODUCT ( Y_i - \bar{Y_i} )C^{i}( Y_i - \bar{Y_i} ), WHERE C^{i}
       ! IS THE PIECE OF THE KINSHIP MATRIX CORRESPONDING THE THIS STRATUM
       ! NOTE THAT i LABELS THE STRATUM, AND IS NOT AN INDEX
       NUM( I, 2 ) = DOT( PHENO( STRAT_START_POSN( I ):STRAT_START_POSN( I ) + N_PEO_STRAT( I ) - 1 ), &
                          C, N_PEO_STRAT( I ) )

       DEALLOCATE( C, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'C', 'MAIN PROGRAM', ALL_STATUS )

      ENDDO


      IF( ALLOCATED( GKIN ) ) THEN
       DEALLOCATE( GKIN, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'GKIN', 'MAIN PROGRAM', ALL_STATUS )
      ENDIF

      ! BOTH THE SNP_INFO FILE, AND THE GENO FILE EXIST FOR THIS CHROMOSOME,
      ! SO READ THEM IN, AND REORDER THE GENO DATA TO THE SAME ORDER AS THE
      ! PHENO DATA

      OPEN( UNIT = 1010, FILE = TRIM( ADJUSTL( GENO_FILE ) ),  &
            STATUS = 'OLD', IOSTAT = IO_STATUS, ACTION = 'READ' )
      IF( IO_STATUS .NE. 0 )  CALL FATAL_FILE_OPENING_ERROR( TRIM( ADJUSTL( GENO_FILE ) ), 'STRATIFIED_ROBUST', IO_STATUS )


      ! ALL THE DATA IS NOW IN PLACE, SO OPEN THE RESULTS FILE
      OPEN( UNIT = 777, FILE = TRIM( ADJUSTL( RESULTS_FILE ) ),  &
            STATUS = 'UNKNOWN', IOSTAT = IO_STATUS )
      IF( IO_STATUS .NE. 0 )  CALL FATAL_FILE_OPENING_ERROR( TRIM( ADJUSTL( RESULTS_FILE ) ), 'STRATIFIED_ROBUST', IO_STATUS )

      WRITE( 777, 100 ) 'snp_id', &
                        'rs_id', &
                        'position', &
                        'A0', &
                        'A1', &
                        'Score', &
                        'Var_standard', &
                        'Var_Kinship', &
                        'Var_Robust', &
                        'Chi_sq', &
                        'Kinship_adjusted', &
                        'Robust'

      ! CALCULATE THE TEST SCORES
      WRITE( *, * )'CALCULATING TEST SCORES.'

      ! LOOP OVER EACH SNP
      ERROR_POS = 0
      DO
       ERROR_POS = ERROR_POS - 1


       IO_STATUS = 0
       ! READ IN THE NEXT LINE OF THE GENO FILE
       READ( 1010, *, IOSTAT = IO_STATUS ) INFO, ALLELES, TEMP_RA

       ! IF THE IO_STATUS IS LESS THAN 0, THEN THE END OF THE FILE HAS BEEN REACHED.
       ! IF IT IS GREATER THAN 0, AN ERROR HAS OCCURRED.
       IF( IO_STATUS .LT. 0 ) THEN
        EXIT
       ELSEIF( IO_STATUS .GT. 0 ) THEN
        CALL FATAL_FILE_READING_ERROR( TRIM( ADJUSTL( GENO_FILE ) ), &
                                       'STRATIFIED_ROBUST', ERROR_POS, IO_STATUS )
       ENDIF

       ! CHECK THAT THERE THE ENTIRE ALLELE HAS BEEN READ IN
       DO I = 1, 2
        IF( LEN_TRIM( ADJUSTL( ALLELES( I ) ) ) .GT. MAX_ALLELE_LENGTH ) THEN
         WRITE( *, 101 ) TRIM( ADJUSTL( INFO( 2 ) ) ), I 
         ALLELES( I ) = 'WARNING'
        ENDIF
       ENDDO


       ! CREATE THE DOSAGES
       DO I = 1, N_PEO
        G( I ) = TEMP_RA( 3*I - 1 ) + 2.D0*TEMP_RA( 3*I )
       ENDDO

       ! NOW REORDER THE GENOTYPE VECTOR
       CALL REORDER( G, N_PEO, ORDER )

       ! RESET THE NUMERATOR AND THE DENOMINATORS TO ZERO
       DENOM = 0_KIND_REAL
       NUMR = 0_KIND_REAL

       ! LOOP OVER EACH STRATUM
       DO I = 1, N_STRAT

        ! TAKE THE SECTION OF THE GENOTYPIC VECTOR CORRESPONDING TO THIS STRATUM,
        ! CALCULATE THE AVERAGE, AND THE VARIANCE, AND SUBREACT THE AVERAGE FOR
        ! THE VECTOR. i.e. CREATE ( G_i - \bar{G_i} ), WHERE i LABELS THE STRATUM
        CALL SUBTRACT_AVERAGE_VAR( G( STRAT_START_POSN( I ): STRAT_START_POSN( I ) + &
                                      N_PEO_STRAT( I ) - 1 ), N_PEO_STRAT( I ), VAR_G )

        ! CALCULATE THE DOT PRODUCT OF ( Y_i - \bar{Y_i} ).( G_i - \bar{G_i} ), WHERE i LABELS THE STRATUM
        NUMR = NUMR + DOT( PHENO( STRAT_START_POSN( I ): STRAT_START_POSN( I ) + &
                           N_PEO_STRAT( I ) - 1 ), G( STRAT_START_POSN( I ): &
                           STRAT_START_POSN( I ) + N_PEO_STRAT( I ) - 1 ), &
                           N_PEO_STRAT( I ) )

        ! ADD TO THE RUNNING SUM OF THE DENOMINATORS
        DENOM( 1 ) = DENOM( 1 ) + VAR_G*NUM( I, 1 )
        DENOM( 2 ) = DENOM( 2 ) + VAR_G*NUM( I, 2 )

        ! LOOP OVER EACH FAMILY
        DO K = 1, N_FAM_STRAT( I )
         ! CALCULATE THE DOT PRODUCT OF ( Y_{i, k} - \bar{Y_i} ). ( G_{i, k} - \bar{G_i} )
         ! AND SUM OVER ALL THE FAMILIES IN THE STRATUM, WHERE i LABELS THE STRATUM,
         ! AND k LABELS THE FAMILY. NOTE THAT WE SUBTRACT THE AVERAGE FOR THE STRATUM.
         TEMP = DOT( PHENO( FAM_START_POSN( I, K ): FAM_START_POSN( I, K ) + &
                     N_PEO_FAM_STRAT( I, K ) - 1 ), G( FAM_START_POSN( I, K ): &
                     FAM_START_POSN( I, K ) + N_PEO_FAM_STRAT( I, K ) - 1 ), &
                     N_PEO_FAM_STRAT( I, K ) )

         ! SQUARE AND ADD TO THE RUNNING SUM OF THE DENOMINATOR
         DENOM( 3 ) = DENOM( 3 ) + ( TEMP )**2
        ENDDO

       ENDDO

       ! WRITE THE TEST SCORES TO THE OUTPUT FILE
       WRITE( WORDS( 1 ), * ) NUMR
       WRITE( WORDS( 2 ), * ) DENOM( 1 )
       WRITE( WORDS( 3 ), * ) DENOM( 2 )
       WRITE( WORDS( 4 ), * ) DENOM( 3 )
       WRITE( WORDS( 5 ), * ) ( NUMR**2 )/DENOM( 1 )
       WRITE( WORDS( 6 ), * ) ( NUMR**2 )/DENOM( 2 )
       WRITE( WORDS( 7 ), * ) ( NUMR**2 )/DENOM( 3 )
       WRITE( 777, 100 ) ( TRIM( ADJUSTL( INFO( I )    ) ), I = 1, 3 ), &
                         ( TRIM( ADJUSTL( ALLELES( K ) ) ), K = 1, 2 ), &
                         ( TRIM( ADJUSTL( WORDS( K )   ) ), K = 1, 7 )

      ENDDO
      CLOSE( 777 )
      CLOSE( 1010 )
      CLOSE( 1011 )


      CALL CLEAN_METHODS( )

      ! DEALLOCATE THE LOCAL VARIABLES
      IF( ALLOCATED( G ) ) THEN
       DEALLOCATE( G, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'G', 'MAIN PROGRAM', ALL_STATUS )
      ENDIF

      IF( ALLOCATED( TEMP_RA ) ) THEN
       DEALLOCATE( TEMP_RA, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'TEMP_RA', 'MAIN PROGRAM', ALL_STATUS )
      ENDIF

      IF( ALLOCATED( NUM ) ) THEN
       DEALLOCATE( NUM, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'NUM', 'MAIN PROGRAM', ALL_STATUS )
      ENDIF

      IF( ALLOCATED( C ) ) THEN
       DEALLOCATE( C, STAT = ALL_STATUS )
       IF( ALL_STATUS .NE. 0 ) CALL DEALLOCATION_ERROR( 'C', 'MAIN PROGRAM', ALL_STATUS )
      ENDIF

      WRITE( *, * )'FINISHING NORMALLY.'

      !THIS IS THE END OF THE PROGRAM
      END PROGRAM  STRATIFIED_ROBUST


!########################################################################################
!########################################################################################
